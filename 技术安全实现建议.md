# 技术安全实现建议

## 代理系统安全强化实现

### 1. IP泄露实时检测模块

#### 实现位置: `src/environment/ProxySecurityManager.js`

```javascript
'use strict';

const axios = require('axios');
const { HttpsProxyAgent } = require('https-proxy-agent');

class ProxySecurityManager {
    constructor() {
        this.monitoringInterval = null;
        this.leakDetectionEnabled = true;
        this.baselineIPs = new Map();
    }

    /**
     * 开始实时IP泄露监控
     * @param {Object} proxyConfig - 代理配置
     */
    async startLeakMonitoring(proxyConfig) {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
        }

        // 记录基线IP
        this.baselineIPs.set('direct', await this.getDirectIP());
        this.baselineIPs.set('proxy', await this.getProxyIP(proxyConfig));

        // 每30秒检查一次
        this.monitoringInterval = setInterval(async () => {
            await this.performLeakCheck(proxyConfig);
        }, 30000);

        console.log('[ProxySecurityManager] 开始IP泄露实时监控');
    }

    /**
     * 执行IP泄露检测
     * @private
     */
    async performLeakCheck(proxyConfig) {
        try {
            const currentProxyIP = await this.getProxyIP(proxyConfig);
            const baselineProxyIP = this.baselineIPs.get('proxy');
            
            if (currentProxyIP !== baselineProxyIP) {
                await this.handleIPChanged(proxyConfig, baselineProxyIP, currentProxyIP);
            }

            // 检测WebRTC泄露
            await this.checkWebRTCLeaks(proxyConfig);
            
            // 检测DNS泄露
            await this.checkDNSLeaks(proxyConfig);

        } catch (error) {
            console.error('[ProxySecurityManager] IP泄露检测失败:', error);
        }
    }

    /**
     * 检测WebRTC IP泄露
     * @private
     */
    async checkWebRTCLeaks(proxyConfig) {
        // WebRTC泄露检测逻辑
        const webrtcLeak = await this.testWebRTCConnection(proxyConfig);
        if (webrtcLeak.leaked) {
            await this.handleWebRTCLeak(webrtcLeak);
        }
    }

    /**
     * 检测DNS泄露
     * @private
     */
    async checkDNSLeaks(proxyConfig) {
        // DNS泄露检测逻辑
        const dnsLeak = await this.testDNSResolution(proxyConfig);
        if (dnsLeak.leaked) {
            await this.handleDNSLeak(dnsLeak);
        }
    }

    /**
     * 处理IP变更事件
     * @private
     */
    async handleIPChanged(proxyConfig, oldIP, newIP) {
        console.warn(`[ProxySecurityManager] IP变更检测: ${oldIP} -> ${newIP}`);
        
        // 更新指纹配置中的IP信息
        await this.updateFingerprintIPs(newIP);
        
        // 重新配置代理
        await this.reconfigureProxy(proxyConfig);
        
        // 发送警报
        await this.sendSecurityAlert('IP变更', { oldIP, newIP });
    }

    /**
     * 更新指纹IP配置
     * @private
     */
    async updateFingerprintIPs(newIP) {
        const fingerprintService = require('../application/services/fingerprint/FingerprintService');
        const accounts = fingerprintService.getAllAccounts();
        
        for (const [accountId, config] of accounts.entries()) {
            config.webrtc.publicIP = newIP;
            fingerprintService.updateFingerprint(accountId, {
                webrtc: config.webrtc
            });
        }
    }

    /**
     * 获取直接连接IP
     * @private
     */
    async getDirectIP() {
        const providers = [
            'https://httpbin.org/ip',
            'https://ipapi.co/json/',
            'https://ipwho.is/'
        ];

        for (const url of providers) {
            try {
                const response = await axios.get(url, { timeout: 5000 });
                const data = response.data;
                return data.origin || data.ip || data.query;
            } catch (error) {
                continue;
            }
        }
        throw new Error('无法获取直接IP');
    }

    /**
     * 获取代理IP
     * @private
     */
    async getProxyIP(proxyConfig) {
        const proxyUrl = ProxyManager.buildProxyUrl(proxyConfig);
        const agent = new HttpsProxyAgent(proxyUrl);

        const response = await axios.get('https://httpbin.org/ip', {
            httpsAgent: agent,
            timeout: 5000
        });

        return response.data.origin;
    }

    /**
     * 测试WebRTC连接
     * @private
     */
    async testWebRTCConnection(proxyConfig) {
        return new Promise((resolve) => {
            const pc = new RTCPeerConnection({
                iceServers: [{
                    urls: 'stun:stun.l.google.com:19302'
                }]
            });

            let leaked = false;
            const timeout = setTimeout(() => {
                pc.close();
                resolve({ leaked: false });
            }, 3000);

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    const ip = event.candidate.candidate.match(/(\d{1,3}\.){3}\d{1,3}/);
                    if (ip && !ip[0].startsWith('192.168.') && !ip[0].startsWith('10.') && !ip[0].startsWith('172.')) {
                        leaked = true;
                        clearTimeout(timeout);
                        pc.close();
                        resolve({ leaked: true, ip: ip[0] });
                    }
                }
            };

            pc.createDataChannel('test');
            pc.createOffer().then(offer => {
                pc.setLocalDescription(offer);
            });
        });
    }

    /**
     * 测试DNS解析
     * @private
     */
    async testDNSResolution(proxyConfig) {
        // DNS泄露检测逻辑
        // 这里需要使用DNS-over-HTTPS或通过代理进行DNS查询
        return { leaked: false };
    }

    /**
     * 发送安全警报
     * @private
     */
    async sendSecurityAlert(type, data) {
        const alert = {
            timestamp: new Date().toISOString(),
            type,
            data,
            severity: this.getSeverityLevel(type)
        };

        // 发送到安全监控日志
        console.error('[安全警报]', JSON.stringify(alert));

        // 可以集成到外部监控系统
        // await this.sendToExternalMonitor(alert);
    }

    /**
     * 获取严重性级别
     * @private
     */
    getSeverityLevel(type) {
        const levels = {
            'IP变更': 'medium',
            'WebRTC泄露': 'high',
            'DNS泄露': 'high',
            '代理失效': 'critical'
        };
        return levels[type] || 'medium';
    }

    /**
     * 停止监控
     */
    stopMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
            console.log('[ProxySecurityManager] 停止IP泄露监控');
        }
    }
}

module.exports = ProxySecurityManager;
```

### 2. 强化DNS保护模块

#### 实现位置: `src/environment/DNSProtectionManager.js`

```javascript
'use strict';

const dns = require('dns').promises;
const { lookup } = require('dns');
const { HttpsProxyAgent } = require('https-proxy-agent');
const axios = require('axios');

class DNSProtectionManager {
    constructor(proxyConfig) {
        this.proxyConfig = proxyConfig;
        this.originalLookup = lookup;
        this.originalResolve4 = dns.resolve4;
        this.originalResolve6 = dns.resolve6;
        this.dohServers = [
            'https://1.1.1.1/dns-query',
            'https://8.8.8.8/dns-query',
            'https://216.36.113.234:11211/dns-query' // 自定义代理DNS
        ];
    }

    /**
     * 启用DNS保护
     */
    enableDNSProtection() {
        // 重写DNS查询函数
        dns.lookup = this.createProtectedLookup.bind(this);
        dns.resolve4 = this.createProtectedResolve4.bind(this);
        dns.resolve6 = this.createProtectedResolve6.bind(this);
        
        console.log('[DNSProtectionManager] DNS保护已启用');
    }

    /**
     * 创建受保护的lookup函数
     * @private
     */
    createProtectedLookup(hostname, options, callback) {
        // 如果是代理服务器域名，直接使用原始lookup
        if (this.isProxyServer(hostname)) {
            return this.originalLookup(hostname, options, callback);
        }

        // 通过代理进行DNS查询
        this.queryDNSOverHTTPS(hostname, options)
            .then(results => {
                callback(null, results[0], results[0].family);
            })
            .catch(error => {
                // 回退到原始DNS
                this.originalLookup(hostname, options, callback);
            });
    }

    /**
     * 创建受保护的resolve4函数
     * @private
     */
    createProtectedResolve4(hostname) {
        if (this.isProxyServer(hostname)) {
            return this.originalResolve4(hostname);
        }

        return this.queryDNSOverHTTPS(hostname, { family: 4 });
    }

    /**
     * 创建受保护的resolve6函数
     * @private
     */
    createProtectedResolve6(hostname) {
        if (this.isProxyServer(hostname)) {
            return this.originalResolve6(hostname);
        }

        return this.queryDNSOverHTTPS(hostname, { family: 6 });
    }

    /**
     * 通过HTTPS进行DNS查询
     * @private
     */
    async queryDNSOverHTTPS(hostname, options = {}) {
        const encodedName = this.base64UrlEncode(hostname);
        
        for (const dohServer of this.dohServers) {
            try {
                const response = await axios.get(`${dohServer}?name=${encodedName}&type=A`, {
                    timeout: 5000,
                    httpsAgent: new HttpsProxyAgent(this.buildProxyURL())
                });

                if (response.data.Answer) {
                    return response.data.Answer.map(answer => ({
                        address: answer.data,
                        family: 4
                    }));
                }
            } catch (error) {
                console.warn(`[DNSProtectionManager] DoH服务器 ${dohServer} 查询失败:`, error.message);
                continue;
            }
        }

        throw new Error('所有DoH服务器查询失败');
    }

    /**
     * 检查是否为主机代理服务器
     * @private
     */
    isProxyServer(hostname) {
        return hostname === this.proxyConfig.host || 
               hostname.includes('216.36.113.234'); // 你的代理IP
    }

    /**
     * 构建代理URL
     * @private
     */
    buildProxyURL() {
        const { protocol, host, port, username, password } = this.proxyConfig;
        let url = `${protocol || 'http'}://${host}:${port}`;
        
        if (username && password) {
            url = `${protocol || 'http'}://${encodeURIComponent(username)}:${encodeURIComponent(password)}@${host}:${port}`;
        }
        
        return url;
    }

    /**
     * Base64 URL编码
     * @private
     */
    base64UrlEncode(str) {
        return Buffer.from(str).toString('base64').replace(/\+/g, '-').replace(/\//g, '_');
    }

    /**
     * 禁用DNS保护
     */
    disableDNSProtection() {
        dns.lookup = this.originalLookup;
        dns.resolve4 = this.originalResolve4;
        dns.resolve6 = this.originalResolve6;
        console.log('[DNSProtectionManager] DNS保护已禁用');
    }
}

module.exports = DNSProtectionManager;
```

## 指纹系统安全强化实现

### 1. 早期指纹注入保证

#### 实现位置: `src/infrastructure/fingerprint/EarlyInjectionManager.js`

```javascript
'use strict';

class EarlyInjectionManager {
    constructor() {
        this.injectionStatus = new Map();
        this.readyStateCheck = null;
    }

    /**
     * 确保指纹在页面加载前注入
     * @param {BrowserView} browserView - Electron BrowserView
     * @param {Object} fingerprintConfig - 指纹配置
     */
    async ensureEarlyInjection(browserView, fingerprintConfig) {
        return new Promise((resolve, reject) => {
            let injected = false;
            const timeout = setTimeout(() => {
                if (!injected) {
                    reject(new Error('指纹早期注入超时'));
                }
            }, 5000);

            // 创建注入脚本
            const injectionScript = this.createEarlyInjectionScript(fingerprintConfig);

            // 监听webContents创建事件
            browserView.webContents.once('did-finish-load', async () => {
                if (!injected) {
                    try {
                        await browserView.webContents.executeJavaScript(injectionScript);
                        injected = true;
                        clearTimeout(timeout);
                        resolve(true);
                    } catch (error) {
                        injected = true;
                        clearTimeout(timeout);
                        reject(error);
                    }
                }
            });

            // 页面加载完成前注入
            browserView.webContents.once('dom-ready', async () => {
                if (!injected) {
                    try {
                        await browserView.webContents.executeJavaScript(injectionScript);
                        injected = true;
                        clearTimeout(timeout);
                        resolve(true);
                    } catch (error) {
                        // dom-ready阶段失败，等待did-finish-load
                        console.warn('[EarlyInjectionManager] dom-ready阶段注入失败，等待did-finish-load');
                    }
                }
            });

            // 立即尝试注入（最高优先级）
            this.attemptImmediateInjection(browserView, injectionScript)
                .then(success => {
                    if (success && !injected) {
                        injected = true;
                        clearTimeout(timeout);
                        resolve(true);
                    }
                })
                .catch(error => {
                    console.warn('[EarlyInjectionManager] 立即注入失败:', error);
                });
        });
    }

    /**
     * 尝试立即注入
     * @private
     */
    async attemptImmediateInjection(browserView, injectionScript) {
        try {
            // 检查webContents是否准备就绪
            if (browserView.webContents && browserView.webContents.isLoading()) {
                return false;
            }

            await browserView.webContents.executeJavaScript(injectionScript);
            console.log('[EarlyInjectionManager] 立即注入成功');
            return true;
        } catch (error) {
            return false;
        }
    }

    /**
     * 创建早期注入脚本
     * @private
     */
    createEarlyInjectionScript(fingerprintConfig) {
        const config = JSON.stringify(fingerprintConfig);
        
        return `
(function() {
    'use strict';
    
    console.log('[EarlyInjection] 开始早期指纹注入');
    
    // 立即执行指纹注入
    (function injectFingerprint() {
        try {
            const config = ${config};
            
            // Navigator属性覆盖
            if (typeof navigator !== 'undefined') {
                Object.defineProperty(navigator, 'userAgent', {
                    get: function() { return config.userAgent; },
                    configurable: true,
                    enumerable: true
                });
                
                Object.defineProperty(navigator, 'platform', {
                    get: function() { return config.os.platform; },
                    configurable: true,
                    enumerable: true
                });
                
                Object.defineProperty(navigator, 'language', {
                    get: function() { return config.language.primary; },
                    configurable: true,
                    enumerable: true
                });
                
                Object.defineProperty(navigator, 'languages', {
                    get: function() { return Object.freeze(config.language.list); },
                    configurable: true,
                    enumerable: true
                });
                
                Object.defineProperty(navigator, 'hardwareConcurrency', {
                    get: function() { return config.hardware.cpuCores; },
                    configurable: true,
                    enumerable: true
                });
                
                Object.defineProperty(navigator, 'deviceMemory', {
                    get: function() { return config.hardware.deviceMemory; },
                    configurable: true,
                    enumerable: true
                });
                
                Object.defineProperty(navigator, 'webdriver', {
                    get: function() { return false; },
                    configurable: true,
                    enumerable: true
                });
            }
            
            // 屏幕信息覆盖
            if (typeof screen !== 'undefined' && config.hardware.screen) {
                Object.defineProperty(screen, 'width', {
                    get: function() { return config.hardware.screen.width; },
                    configurable: true,
                    enumerable: true
                });
                
                Object.defineProperty(screen, 'height', {
                    get: function() { return config.hardware.screen.height; },
                    configurable: true,
                    enumerable: true
                });
                
                Object.defineProperty(screen, 'colorDepth', {
                    get: function() { return config.hardware.screen.colorDepth; },
                    configurable: true,
                    enumerable: true
                });
            }
            
            // WebRTC IP替换
            if (typeof RTCPeerConnection !== 'undefined' && config.webrtc) {
                const OriginalRTCPeerConnection = RTCPeerConnection;
                
                window.RTCPeerConnection = function(config) {
                    const originalConfig = config || {};
                    
                    // 确保使用代理的STUN服务器
                    if (!originalConfig.iceServers) {
                        originalConfig.iceServers = [];
                    }
                    
                    originalConfig.iceServers = originalConfig.iceServers.filter(server => {
                        return !server.urls || !server.urls.includes('stun:stun.l.google.com:19302');
                    });
                    
                    // 添加代理STUN服务器
                    originalConfig.iceServers.push({
                        urls: 'stun:${fingerprintConfig.webrtc.publicIP || '216.36.113.234'}:3478'
                    });
                    
                    return new OriginalRTCPeerConnection(originalConfig);
                };
                
                window.RTCPeerConnection.prototype = OriginalRTCPeerConnection.prototype;
                Object.defineProperty(window.RTCPeerConnection, 'name', {
                    value: 'RTCPeerConnection',
                    configurable: true
                });
            }
            
            console.log('[EarlyInjection] 指纹早期注入完成');
            window.__fingerprint_injected__ = true;
            
        } catch (error) {
            console.error('[EarlyInjection] 指纹注入失败:', error);
        }
    })();
    
    // 页面加载完成后再次验证
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            if (!window.__fingerprint_injected__) {
                console.warn('[EarlyInjection] 页面加载完成但指纹未注入，重新注入');
                injectFingerprint();
            }
        });
    }
})();
        `.trim();
    }

    /**
     * 验证指纹注入状态
     * @param {BrowserView} browserView - Electron BrowserView
     */
    async verifyInjection(browserView) {
        try {
            const result = await browserView.webContents.executeJavaScript(`
                typeof window.__fingerprint_injected__ !== 'undefined' && window.__fingerprint_injected__ === true
            `);
            
            if (!result) {
                console.warn('[EarlyInjection] 指纹注入验证失败，重新注入');
                return await this.retryInjection(browserView);
            }
            
            return true;
        } catch (error) {
            console.error('[EarlyInjection] 验证过程中出错:', error);
            return false;
        }
    }

    /**
     * 重试注入
     * @private
     */
    async retryInjection(browserView) {
        const fingerprintConfig = this.getFingerprintConfigForView(browserView);
        if (!fingerprintConfig) {
            return false;
        }

        try {
            const injectionScript = this.createEarlyInjectionScript(fingerprintConfig);
            await browserView.webContents.executeJavaScript(injectionScript);
            console.log('[EarlyInjection] 重试注入成功');
            return true;
        } catch (error) {
            console.error('[EarlyInjection] 重试注入失败:', error);
            return false;
        }
    }

    /**
     * 获取BrowserView的指纹配置
     * @private
     */
    getFingerprintConfigForView(browserView) {
        // 从指纹服务获取对应配置
        const fingerprintService = require('../../application/services/fingerprint/FingerprintService');
        // 这里需要根据实际实现获取对应的指纹配置
        return null;
    }
}

module.exports = EarlyInjectionManager;
```

### 2. 增强错误恢复机制

#### 实现位置: `src/infrastructure/fingerprint/InjectionRecoveryManager.js`

```javascript
'use strict';

class InjectionRecoveryManager {
    constructor() {
        this.retryStrategies = [
            { name: 'immediate', delay: 100, maxRetries: 3 },
            { name: 'delayed', delay: 1000, maxRetries: 5 },
            { name: 'gradual', delay: 5000, maxRetries: 10 }
        ];
        this.injectionHistory = new Map();
    }

    /**
     * 带恢复机制的指纹注入
     * @param {BrowserView} browserView - Electron BrowserView
     * @param {Object} fingerprintConfig - 指纹配置
     * @param {Object} options - 注入选项
     */
    async injectWithRecovery(browserView, fingerprintConfig, options = {}) {
        const accountId = options.accountId || 'unknown';
        const strategy = options.retryStrategy || 'gradual';
        
        console.log(`[InjectionRecovery] 开始带恢复的指纹注入，账户: ${accountId}, 策略: ${strategy}`);
        
        // 记录注入历史
        this.recordInjectionAttempt(accountId);
        
        let lastError = null;
        for (const attempt of this.retryStrategies.filter(s => s.name === strategy)) {
            try {
                const success = await this.attemptInjectionWithFallback(
                    browserView, 
                    fingerprintConfig, 
                    attempt
                );
                
                if (success) {
                    console.log(`[InjectionRecovery] 指纹注入成功，账户: ${accountId}`);
                    this.clearInjectionHistory(accountId);
                    return true;
                }
                
                lastError = new Error(`策略 ${attempt.name} 失败`);
            } catch (error) {
                lastError = error;
                console.warn(`[InjectionRecovery] 策略 ${attempt.name} 出错:`, error.message);
                
                // 应用指数退避
                await this.applyExponentialBackoff(attempt.delay, attempt.maxRetries);
            }
        }
        
        // 所有策略都失败，发送告警
        await this.handleInjectionFailure(accountId, lastError);
        return false;
    }

    /**
     * 尝试注入并使用回退机制
     * @private
     */
    async attemptInjectionWithFallback(browserView, config, strategy) {
        const attempts = strategy.maxRetries || 3;
        
        for (let i = 0; i < attempts; i++) {
            try {
                // 主要注入方法
                await this.primaryInjection(browserView, config);
                return true;
            } catch (error) {
                console.warn(`[InjectionRecovery] 主要注入失败 (尝试 ${i + 1}/${attempts}):`, error.message);
                
                // 尝试回退注入方法
                try {
                    await this.fallbackInjection(browserView, config);
                    console.log(`[InjectionRecovery] 回退注入成功 (尝试 ${i + 1}/${attempts})`);
                    return true;
                } catch (fallbackError) {
                    console.warn(`[InjectionRecovery] 回退注入也失败 (尝试 ${i + 1}/${attempts}):`, fallbackError.message);
                }
                
                // 如果不是最后一次尝试，等待延迟
                if (i < attempts - 1) {
                    await this.sleep(strategy.delay * Math.pow(2, i)); // 指数退避
                }
            }
        }
        
        return false;
    }

    /**
     * 主要注入方法
     * @private
     */
    async primaryInjection(browserView, config) {
        const injector = new (require('./FingerprintInjector'))(config);
        const script = injector.getInjectionScript({ minify: false });
        
        await browserView.webContents.executeJavaScript(script);
    }

    /**
     * 回退注入方法
     * @private
     */
    async fallbackInjection(browserView, config) {
        // 简化的注入脚本，只覆盖关键属性
        const minimalScript = this.createMinimalInjectionScript(config);
        
        await browserView.webContents.executeJavaScript(minimalScript);
    }

    /**
     * 创建最小化注入脚本
     * @private
     */
    createMinimalInjectionScript(config) {
        return `
(function() {
    'use strict';
    
    try {
        // 最基本的User-Agent覆盖
        if (typeof navigator !== 'undefined' && '${config.userAgent}') {
            Object.defineProperty(navigator, 'userAgent', {
                get: function() { return '${config.userAgent}'; },
                configurable: true
            });
        }
        
        // WebRTC保护
        if (typeof RTCPeerConnection !== 'undefined') {
            window.RTCPeerConnection = window.RTCPeerConnection;
        }
        
        console.log('[FallbackInjection] 最小化指纹注入完成');
    } catch (error) {
        console.error('[FallbackInjection] 最小化注入失败:', error);
    }
})();
        `.trim();
    }

    /**
     * 应用指数退避
     * @private
     */
    async applyExponentialBackoff(baseDelay, maxRetries) {
        const delay = Math.min(baseDelay * Math.pow(2, maxRetries), 30000); // 最大30秒
        await this.sleep(delay);
    }

    /**
     * 睡眠函数
     * @private
     */
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * 记录注入尝试
     * @private
     */
    recordInjectionAttempt(accountId) {
        if (!this.injectionHistory.has(accountId)) {
            this.injectionHistory.set(accountId, {
                attempts: 0,
                failures: 0,
                lastAttempt: null,
                strategies: []
            });
        }
        
        const history = this.injectionHistory.get(accountId);
        history.attempts++;
        history.lastAttempt = new Date();
        history.strategies.push({
            name: 'recovery',
            timestamp: new Date()
        });
    }

    /**
     * 清除注入历史
     * @private
     */
    clearInjectionHistory(accountId) {
        this.injectionHistory.delete(accountId);
    }

    /**
     * 处理注入失败
     * @private
     */
    async handleInjectionFailure(accountId, error) {
        const history = this.injectionHistory.get(accountId);
        
        console.error(`[InjectionRecovery] 指纹注入最终失败，账户: ${accountId}`, error);
        
        // 发送安全告警
        await this.sendFailureAlert(accountId, error, history);
        
        // 记录到日志
        this.logInjectionFailure(accountId, error, history);
    }

    /**
     * 发送失败告警
     * @private
     */
    async sendFailureAlert(accountId, error, history) {
        const alert = {
            type: 'FINGERPRINT_INJECTION_FAILURE',
            accountId,
            error: error.message,
            history: {
                attempts: history.attempts,
                failures: history.failures,
                lastAttempt: history.lastAttempt,
                strategies: history.strategies
            },
            timestamp: new Date().toISOString(),
            severity: 'high'
        };
        
        console.error('[安全告警]', JSON.stringify(alert));
    }

    /**
     * 记录注入失败日志
     * @private
     */
    logInjectionFailure(accountId, error, history) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            level: 'error',
            message: `指纹注入失败 - 账户: ${accountId}`,
            error: {
                message: error.message,
                stack: error.stack
            },
            context: {
                attempts: history.attempts,
                failures: history.failures,
                strategies: history.strategies
            }
        };
        
        // 写入日志文件或发送到日志系统
        console.log('[指纹注入失败日志]', JSON.stringify(logEntry));
    }
}

module.exports = InjectionRecoveryManager;
```

## 监控和警报系统

### 3. 安全监控中心

#### 实现位置: `src/security/SecurityMonitor.js`

```javascript
'use strict';

const fs = require('fs').promises;
const path = require('path');

class SecurityMonitor {
    constructor() {
        this.alertRules = new Map();
        this.monitoringRules = new Map();
        this.alertHistory = [];
        this.maxHistorySize = 1000;
        this.init();
    }

    /**
     * 初始化监控
     */
    async init() {
        await this.loadAlertRules();
        await this.startMonitoring();
        console.log('[SecurityMonitor] 安全监控中心已启动');
    }

    /**
     * 加载警报规则
     * @private
     */
    async loadAlertRules() {
        this.alertRules.set('IP_LEAK', {
            severity: 'high',
            threshold: 1,
            window: 300000, // 5分钟窗口
            actions: ['log', 'alert']
        });

        this.alertRules.set('DNS_LEAK', {
            severity: 'critical',
            threshold: 1,
            window: 0, // 立即触发
            actions: ['log', 'alert', 'block']
        });

        this.alertRules.set('WEBRTC_LEAK', {
            severity: 'high',
            threshold: 1,
            window: 60000, // 1分钟窗口
            actions: ['log', 'alert']
        });

        this.alertRules.set('FINGERPRINT_INJECTION_FAILURE', {
            severity: 'medium',
            threshold: 3,
            window: 300000, // 5分钟窗口
            actions: ['log']
        });
    }

    /**
     * 记录安全事件
     * @param {string} eventType - 事件类型
     * @param {Object} eventData - 事件数据
     * @param {string} source - 事件来源
     */
    async recordSecurityEvent(eventType, eventData, source = 'unknown') {
        const event = {
            id: this.generateEventId(),
            type: eventType,
            data: eventData,
            source,
            timestamp: new Date().toISOString(),
            processed: false
        };

        // 添加到历史记录
        this.alertHistory.push(event);
        if (this.alertHistory.length > this.maxHistorySize) {
            this.alertHistory = this.alertHistory.slice(-this.maxHistorySize);
        }

        // 检查是否触发警报
        await this.checkAlertRules(event);
        
        // 记录到日志文件
        await this.logEvent(event);
    }

    /**
     * 检查警报规则
     * @private
     */
    async checkAlertRules(event) {
        const rule = this.alertRules.get(event.type);
        if (!rule) return;

        const recentEvents = this.getRecentEvents(event.type, rule.window);
        const eventCount = recentEvents.length + 1; // 包括当前事件

        if (eventCount >= rule.threshold) {
            await this.triggerAlert(event, rule, eventCount);
        }
    }

    /**
     * 触发警报
     * @private
     */
    async triggerAlert(event, rule, count) {
        const alert = {
            id: this.generateAlertId(),
            eventType: event.type,
            severity: rule.severity,
            count,
            timestamp: new Date().toISOString(),
            actions: rule.actions,
            event: event
        };

        // 执行警报动作
        for (const action of rule.actions) {
            await this.executeAction(action, alert);
        }

        console.warn(`[SecurityMonitor] 触发警报: ${event.type} (${rule.severity})`);
    }

    /**
     * 执行警报动作
     * @private
     */
    async executeAction(action, alert) {
        switch (action) {
            case 'log':
                console.error('[安全警报]', JSON.stringify(alert));
                break;
                
            case 'alert':
                await this.sendAlert(alert);
                break;
                
            case 'block':
                await this.executeBlockAction(alert);
                break;
                
            case 'notify':
                await this.sendNotification(alert);
                break;
        }
    }

    /**
     * 发送警报通知
     * @private
     */
    async sendAlert(alert) {
        // 可以集成到外部通知系统
        const alertMessage = {
            title: `安全警报: ${alert.eventType}`,
            body: `${alert.eventType} 检测到 ${alert.count} 次事件 (严重性: ${alert.severity})`,
            severity: alert.severity,
            timestamp: alert.timestamp
        };
        
        console.log('[安全警报通知]', JSON.stringify(alertMessage));
        
        // 这里可以集成到钉钉、微信、邮件等通知系统
        // await this.sendToExternalSystem(alertMessage);
    }

    /**
     * 执行阻止动作
     * @private
     */
    async executeBlockAction(alert) {
        console.warn(`[SecurityMonitor] 执行阻止动作: ${alert.eventType}`);
        
        // 根据事件类型执行不同的阻止动作
        switch (alert.eventType) {
            case 'DNS_LEAK':
                // 临时禁用DNS保护，重新配置
                await this.handleDNSLeakBlock(alert);
                break;
                
            case 'WEBRTC_LEAK':
                // 强化WebRTC保护
                await this.handleWebRTCLeakBlock(alert);
                break;
        }
    }

    /**
     * 处理DNS泄露阻止
     * @private
     */
    async handleDNSLeakBlock(alert) {
        console.warn('[SecurityMonitor] DNS泄露阻止：重新配置DNS保护');
        
        // 重新启用DNS保护
        const dnsManager = require('../environment/DNSProtectionManager');
        // dnsManager.enableDNSProtection();
        
        // 记录阻止事件
        await this.recordSecurityEvent('DNS_PROTECTION_BLOCK', {
            reason: 'DNS泄露阻止',
            originalEvent: alert.event
        }, 'SecurityMonitor');
    }

    /**
     * 处理WebRTC泄露阻止
     * @private
     */
    async handleWebRTCLeakBlock(alert) {
        console.warn('[SecurityMonitor] WebRTC泄露阻止：强化WebRTC保护');
        
        // 强化WebRTC保护设置
        const webrtcConfig = {
            mode: 'block',
            blockedIPs: alert.event.data.leakedIPs || []
        };
        
        // 更新指纹配置中的WebRTC设置
        const fingerprintService = require('../application/services/fingerprint/FingerprintService');
        fingerprintService.updateWebRTCConfig(webrtcConfig);
        
        // 记录阻止事件
        await this.recordSecurityEvent('WEBRTC_PROTECTION_BLOCK', {
            reason: 'WebRTC泄露阻止',
            originalEvent: alert.event
        }, 'SecurityMonitor');
    }

    /**
     * 获取最近事件
     * @private
     */
    getRecentEvents(eventType, windowMs) {
        if (windowMs === 0) {
            // 立即触发，返回空数组（只计算当前事件）
            return [];
        }

        const cutoffTime = new Date(Date.now() - windowMs);
        return this.alertHistory.filter(event => 
            event.type === eventType && 
            new Date(event.timestamp) > cutoffTime
        );
    }

    /**
     * 记录事件到文件
     * @private
     */
    async logEvent(event) {
        const logDir = path.join(process.cwd(), 'logs', 'security');
        await fs.mkdir(logDir, { recursive: true });
        
        const logFile = path.join(logDir, `security-${new Date().toISOString().split('T')[0]}.log`);
        const logEntry = JSON.stringify(event) + '\n';
        
        await fs.appendFile(logFile, logEntry);
    }

    /**
     * 生成事件ID
     * @private
     */
    generateEventId() {
        return `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * 生成警报ID
     * @private
     */
    generateAlertId() {
        return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * 开始监控
     * @private
     */
    async startMonitoring() {
        // 启动定期健康检查
        setInterval(() => {
            this.performHealthCheck();
        }, 60000); // 每分钟检查一次
    }

    /**
     * 执行健康检查
     * @private
     */
    async performHealthCheck() {
        try {
            // 检查代理连接状态
            await this.checkProxyHealth();
            
            // 检查指纹注入状态
            await this.checkFingerprintHealth();
            
            // 检查系统资源使用
            await this.checkResourceHealth();
            
        } catch (error) {
            console.error('[SecurityMonitor] 健康检查失败:', error);
        }
    }

    /**
     * 检查代理健康状态
     * @private
     */
    async checkProxyHealth() {
        // 检查代理连接状态
        const proxyManager = require('../environment/ProxyManager');
        // proxyManager.healthCheck();
    }

    /**
     * 检查指纹健康状态
     * @private
     */
    async checkFingerprintHealth() {
        // 检查指纹注入成功率
        const fingerprintService = require('../application/services/fingerprint/FingerprintService');
        // fingerprintService.getInjectionStats();
    }

    /**
     * 检查资源健康状态
     * @private
     */
    async checkResourceHealth() {
        // 检查内存使用
        const memUsage = process.memoryUsage();
        if (memUsage.heapUsed > 500 * 1024 * 1024) { // 500MB
            console.warn('[SecurityMonitor] 内存使用过高:', memUsage);
        }
    }

    /**
     * 获取监控报告
     */
    getMonitoringReport() {
        const now = new Date();
        const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        
        const recentEvents = this.alertHistory.filter(event => 
            new Date(event.timestamp) > last24Hours
        );
        
        const eventCounts = recentEvents.reduce((counts, event) => {
            counts[event.type] = (counts[event.type] || 0) + 1;
            return counts;
        }, {});

        return {
            summary: {
                totalEvents: recentEvents.length,
                uniqueTypes: Object.keys(eventCounts).length,
                timeRange: '24 hours'
            },
            eventCounts,
            recentEvents: recentEvents.slice(-10), // 最近10个事件
            timestamp: now.toISOString()
        };
    }
}

module.exports = SecurityMonitor;
```

这些技术实现建议提供了具体的安全强化代码，可以直接集成到现有系统中，提高代理和指纹系统的安全性。